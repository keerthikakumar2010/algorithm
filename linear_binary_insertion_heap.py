# -*- coding: utf-8 -*-
"""linear binary insertion heap.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gJy3Mqc-Ax549p6ENzkE1vW3mJ2vxSav
"""

import time
import matplotlib.pyplot as plt

# Linear search function
def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i
    return -1

# Function to calculate time taken for linear search for different values of n
def time_linear_search(n_values):
    times = []
    for n in n_values:
        arr = list(range(n))  # Generate list of n elements
        target = n - 1  # Choose the target to be the last element
        start_time = time.time()
        linear_search(arr, target)
        end_time = time.time()
        times.append(end_time - start_time)
    return times

# Values for n
n_values = [10, 100, 1000, 5000, 10000, 20000, 50000]

# Get the times for linear search
times = time_linear_search(n_values)

# Plotting the graph
plt.plot(n_values, times, marker='o', linestyle='-', color='b')
plt.xlabel('Number of Elements (n)')
plt.ylabel('Time Taken (seconds)')
plt.title('Linear Search: Time Taken vs n')
plt.grid(True)
plt.show()

import time
import matplotlib.pyplot as plt

# Recursive binary search function
def binary_search(arr, target, low, high):
    if low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] > target:
            return binary_search(arr, target, low, mid - 1)
        else:
            return binary_search(arr, target, mid + 1, high)
    return -1

# Function to calculate time taken for binary search for different values of n
def time_binary_search(n_values):
    times = []
    for n in n_values:
        arr = list(range(n))  # Generate a sorted list of n elements
        target = n - 1  # Choose the target to be the last element
        start_time = time.time()
        binary_search(arr, target, 0, len(arr) - 1)
        end_time = time.time()
        times.append(end_time - start_time)
    return times

# Values for n
n_values = [10, 100, 1000, 5000, 10000, 20000, 50000]

# Get the times for binary search
times = time_binary_search(n_values)

# Plotting the graph
plt.plot(n_values, times, marker='o', linestyle='-', color='r')
plt.xlabel('Number of Elements (n)')
plt.ylabel('Time Taken (seconds)')
plt.title('Binary Search (Recursive): Time Taken vs n')
plt.grid(True)
plt.show()

import time
import random
import heapq
import matplotlib.pyplot as plt

# Insertion Sort function
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key

# Heap Sort function
def heap_sort(arr):
    heapq.heapify(arr)
    return [heapq.heappop(arr) for _ in range(len(arr))]

# Function to calculate time taken for sorting for different values of n
def time_sorting_algorithms(n_values):
    insertion_sort_times = []
    heap_sort_times = []

    for n in n_values:
        arr = [random.randint(0, 10000) for _ in range(n)]  # Generate random list of n elements

        # Insertion Sort
        start_time = time.time()
        insertion_sort(arr.copy())  # Use a copy to not affect Heap Sort
        end_time = time.time()
        insertion_sort_times.append(end_time - start_time)

        # Heap Sort
        start_time = time.time()
        heap_sort(arr.copy())  # Use a copy to not affect Insertion Sort
        end_time = time.time()
        heap_sort_times.append(end_time - start_time)

    return insertion_sort_times, heap_sort_times

# Values for n
n_values = [10, 100, 500, 1000, 5000, 10000]

# Get the times for Insertion Sort and Heap Sort
insertion_sort_times, heap_sort_times = time_sorting_algorithms(n_values)

# Plotting the graph
plt.plot(n_values, insertion_sort_times, marker='o', linestyle='-', color='b', label='Insertion Sort')
plt.plot(n_values, heap_sort_times, marker='x', linestyle='-', color='r', label='Heap Sort')
plt.xlabel('Number of Elements (n)')
plt.ylabel('Time Taken (seconds)')
plt.title('Sorting Algorithms: Time Taken vs n')
plt.legend()
plt.grid(True)
plt.show()